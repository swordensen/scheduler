{"ast":null,"code":"/**\n * @license Angular v16.2.3\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked$1(() => subject.error(err));\n      return;\n    }\n    untracked$1(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /*#__PURE__*/Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n  return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nfunction createSignalFromFunction(node, fn, extraApi = {}) {\n  fn[SIGNAL] = node;\n  // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n  return Object.assign(fn, extraApi);\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\nconst _global = globalThis;\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0\n  };\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  deref() {\n    return this.ref;\n  }\n}\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl = _global['WeakRef'] ?? LeakyRef;\nfunction newWeakRef(value) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n    throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n  }\n  return new WeakRefImpl(value);\n}\nfunction setAlternateWeakRefImpl(impl) {\n  // no-op since the alternate impl is included by default by the framework. Remove once internal\n  // migration is complete.\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId = 0;\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer = null;\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nclass ReactiveNode {\n  constructor() {\n    this.id = _nextReactiveId++;\n    /**\n     * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n     */\n    this.ref = newWeakRef(this);\n    /**\n     * Edges to producers on which this node depends (in its consumer capacity).\n     */\n    this.producers = new Map();\n    /**\n     * Edges to consumers on which this node depends (in its producer capacity).\n     */\n    this.consumers = new Map();\n    /**\n     * Monotonically increasing counter representing a version of this `Consumer`'s\n     * dependencies.\n     */\n    this.trackingVersion = 0;\n    /**\n     * Monotonically increasing counter which increases when the value of this `Producer`\n     * semantically changes.\n     */\n    this.valueVersion = 0;\n  }\n  /**\n   * Polls dependencies of a consumer to determine if they have actually changed.\n   *\n   * If this returns `false`, then even though the consumer may have previously been notified of a\n   * change, the values of its dependencies have not actually changed and the consumer should not\n   * rerun any reactions.\n   */\n  consumerPollProducersForChange() {\n    for (const [producerId, edge] of this.producers) {\n      const producer = edge.producerNode.deref();\n      // On Safari < 16.1 deref can return null, we need to check for null also.\n      // See https://github.com/WebKit/WebKit/commit/44c15ba58912faab38b534fef909dd9e13e095e0\n      if (producer == null || edge.atTrackingVersion !== this.trackingVersion) {\n        // This dependency edge is stale, so remove it.\n        this.producers.delete(producerId);\n        producer?.consumers.delete(this.id);\n        continue;\n      }\n      if (producer.producerPollStatus(edge.seenValueVersion)) {\n        // One of the dependencies reports a real value change.\n        return true;\n      }\n    }\n    // No dependency reported a real value change, so the `Consumer` has also not been\n    // impacted.\n    return false;\n  }\n  /**\n   * Notify all consumers of this producer that its value may have changed.\n   */\n  producerMayHaveChanged() {\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n      for (const [consumerId, edge] of this.consumers) {\n        const consumer = edge.consumerNode.deref();\n        // On Safari < 16.1 deref can return null, we need to check for null also.\n        // See https://github.com/WebKit/WebKit/commit/44c15ba58912faab38b534fef909dd9e13e095e0\n        if (consumer == null || consumer.trackingVersion !== edge.atTrackingVersion) {\n          this.consumers.delete(consumerId);\n          consumer?.producers.delete(this.id);\n          continue;\n        }\n        consumer.onConsumerDependencyMayHaveChanged();\n      }\n    } finally {\n      inNotificationPhase = prev;\n    }\n  }\n  /**\n   * Mark that this producer node has been accessed in the current reactive context.\n   */\n  producerAccessed() {\n    if (inNotificationPhase) {\n      throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n    }\n    if (activeConsumer === null) {\n      return;\n    }\n    // Either create or update the dependency `Edge` in both directions.\n    let edge = activeConsumer.producers.get(this.id);\n    if (edge === undefined) {\n      edge = {\n        consumerNode: activeConsumer.ref,\n        producerNode: this.ref,\n        seenValueVersion: this.valueVersion,\n        atTrackingVersion: activeConsumer.trackingVersion\n      };\n      activeConsumer.producers.set(this.id, edge);\n      this.consumers.set(activeConsumer.id, edge);\n    } else {\n      edge.seenValueVersion = this.valueVersion;\n      edge.atTrackingVersion = activeConsumer.trackingVersion;\n    }\n  }\n  /**\n   * Whether this consumer currently has any producers registered.\n   */\n  get hasProducers() {\n    return this.producers.size > 0;\n  }\n  /**\n   * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n   * based on the current consumer context.\n   */\n  get producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n  }\n  /**\n   * Checks if a `Producer` has a current value which is different than the value\n   * last seen at a specific version by a `Consumer` which recorded a dependency on\n   * this `Producer`.\n   */\n  producerPollStatus(lastSeenValueVersion) {\n    // `producer.valueVersion` may be stale, but a mismatch still means that the value\n    // last seen by the `Consumer` is also stale.\n    if (this.valueVersion !== lastSeenValueVersion) {\n      return true;\n    }\n    // Trigger the `Producer` to update its `valueVersion` if necessary.\n    this.onProducerUpdateValueVersion();\n    // At this point, we can trust `producer.valueVersion`.\n    return this.valueVersion !== lastSeenValueVersion;\n  }\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n  const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  return createSignalFromFunction(node, node.signal.bind(node));\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /*#__PURE__*/Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /*#__PURE__*/Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /*#__PURE__*/Symbol('ERRORED');\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl extends ReactiveNode {\n  constructor(computation, equal) {\n    super();\n    this.computation = computation;\n    this.equal = equal;\n    /**\n     * Current value of the computation.\n     *\n     * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n     */\n    this.value = UNSET;\n    /**\n     * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n     * be re-thrown.\n     */\n    this.error = null;\n    /**\n     * Flag indicating that the computation is currently stale, meaning that one of the\n     * dependencies has notified of a potential change.\n     *\n     * It's possible that no dependency has _actually_ changed, in which case the `stale`\n     * state can be resolved without recomputing the value.\n     */\n    this.stale = true;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    if (this.stale) {\n      // We've already notified consumers that this value has potentially changed.\n      return;\n    }\n    // Record that the currently cached value may be stale.\n    this.stale = true;\n    // Notify any consumers about the potential change.\n    this.producerMayHaveChanged();\n  }\n  onProducerUpdateValueVersion() {\n    if (!this.stale) {\n      // The current value and its version are already up to date.\n      return;\n    }\n    // The current value is stale. Check whether we need to produce a new one.\n    if (this.value !== UNSET && this.value !== COMPUTING && !this.consumerPollProducersForChange()) {\n      // Even though we were previously notified of a potential dependency update, all of\n      // our dependencies report that they have not actually changed in value, so we can\n      // resolve the stale state without needing to recompute the current value.\n      this.stale = false;\n      return;\n    }\n    // The current value is stale, and needs to be recomputed. It still may not change -\n    // that depends on whether the newly computed value is equal to the old.\n    this.recomputeValue();\n  }\n  recomputeValue() {\n    if (this.value === COMPUTING) {\n      // Our computation somehow led to a cyclic read of itself.\n      throw new Error('Detected cycle in computations.');\n    }\n    const oldValue = this.value;\n    this.value = COMPUTING;\n    // As we're re-running the computation, update our dependent tracking version number.\n    this.trackingVersion++;\n    const prevConsumer = setActiveConsumer(this);\n    let newValue;\n    try {\n      newValue = this.computation();\n    } catch (err) {\n      newValue = ERRORED;\n      this.error = err;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n    this.stale = false;\n    if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && this.equal(oldValue, newValue)) {\n      // No change to `valueVersion` - old and new values are\n      // semantically equivalent.\n      this.value = oldValue;\n      return;\n    }\n    this.value = newValue;\n    this.valueVersion++;\n  }\n  signal() {\n    // Check if the value needs updating before returning it.\n    this.onProducerUpdateValueVersion();\n    // Record that someone looked at this signal.\n    this.producerAccessed();\n    if (this.value === ERRORED) {\n      throw this.error;\n    }\n    return this.value;\n  }\n}\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\nclass WritableSignalImpl extends ReactiveNode {\n  constructor(value, equal) {\n    super();\n    this.value = value;\n    this.equal = equal;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    // This never happens for writable signals as they're not consumers.\n  }\n  onProducerUpdateValueVersion() {\n    // Writable signal value versions are always up to date.\n  }\n  /**\n   * Directly update the value of the signal to a new value, which may or may not be\n   * equal to the previous.\n   *\n   * In the event that `newValue` is semantically equal to the current value, `set` is\n   * a no-op.\n   */\n  set(newValue) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    if (!this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.valueVersion++;\n      this.producerMayHaveChanged();\n      postSignalSetFn?.();\n    }\n  }\n  /**\n   * Derive a new value for the signal from its current value using the `updater` function.\n   *\n   * This is equivalent to calling `set` on the result of running `updater` on the current\n   * value.\n   */\n  update(updater) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    this.set(updater(this.value));\n  }\n  /**\n   * Calls `mutator` on the current value and assumes that it has been mutated.\n   */\n  mutate(mutator) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(this.value);\n    this.valueVersion++;\n    this.producerMayHaveChanged();\n    postSignalSetFn?.();\n  }\n  asReadonly() {\n    if (this.readonlySignal === undefined) {\n      this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n    }\n    return this.readonlySignal;\n  }\n  signal() {\n    this.producerAccessed();\n    return this.value;\n  }\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n  const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n    set: signalNode.set.bind(signalNode),\n    update: signalNode.update.bind(signalNode),\n    mutate: signalNode.mutate.bind(signalNode),\n    asReadonly: signalNode.asReadonly.bind(signalNode)\n  });\n  return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nconst NOOP_CLEANUP_FN = () => {};\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nclass Watch extends ReactiveNode {\n  constructor(watch, schedule, allowSignalWrites) {\n    super();\n    this.watch = watch;\n    this.schedule = schedule;\n    this.dirty = false;\n    this.cleanupFn = NOOP_CLEANUP_FN;\n    this.registerOnCleanup = cleanupFn => {\n      this.cleanupFn = cleanupFn;\n    };\n    this.consumerAllowSignalWrites = allowSignalWrites;\n  }\n  notify() {\n    if (!this.dirty) {\n      this.schedule(this);\n    }\n    this.dirty = true;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    this.notify();\n  }\n  onProducerUpdateValueVersion() {\n    // Watches are not producers.\n  }\n  /**\n   * Execute the reactive expression in the context of this `Watch` consumer.\n   *\n   * Should be called by the user scheduling algorithm when the provided\n   * `schedule` hook is called by `Watch`.\n   */\n  run() {\n    this.dirty = false;\n    if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer(this);\n    this.trackingVersion++;\n    try {\n      this.cleanupFn();\n      this.cleanupFn = NOOP_CLEANUP_FN;\n      this.watch(this.registerOnCleanup);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  cleanup() {\n    this.cleanupFn();\n  }\n}\nfunction toSignal(source, options) {\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal$1({\n      kind: 0 /* StateKind.NoValue */\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal$1({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    });\n  }\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => state.set({\n      kind: 2 /* StateKind.Error */,\n      error\n    })\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (ngDevMode && options?.requireSync && untracked(state).kind === 0 /* StateKind.NoValue */) {\n    throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed$1(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };\n//# sourceMappingURL=rxjs-interop.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}